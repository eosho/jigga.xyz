# Postgres Restore WorkflowTemplate
# Supports full cluster restore or single database restore
# Uses the postgres-restore.sh script from ConfigMap
apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: postgres-restore
  namespace: argo-workflows
  labels:
    app.kubernetes.io/name: postgres-restore
    app.kubernetes.io/component: workflow-template
spec:
  entrypoint: restore-with-approval
  serviceAccountName: argo-workflow

  # Input parameters
  arguments:
    parameters:
      - name: backup-file
        description: "Backup file name (e.g., postgres-backup-20260120-020000.sql.gz) or 'latest'"
        value: "latest"
      - name: target-database
        description: "Single database to restore (leave empty for full restore)"
        value: ""
      - name: skip-approval
        description: "Skip manual approval step (use with caution)"
        value: "false"

  # Volumes
  volumes:
    - name: backup
      nfs:
        server: 192.168.1.246
        path: /mnt/truenas-pool/pve/k8s/postgres
    - name: scripts
      configMap:
        name: postgres-scripts
        defaultMode: 0755

  templates:
    # Main entrypoint with approval gate
    - name: restore-with-approval
      steps:
        - - name: list-backups
            template: list-available-backups
        - - name: resolve-backup
            template: resolve-backup-file
            arguments:
              parameters:
                - name: requested-file
                  value: "{{workflow.parameters.backup-file}}"
        - - name: verify-backup
            template: verify-backup-contents
            arguments:
              parameters:
                - name: backup-file
                  value: "{{steps.resolve-backup.outputs.parameters.backup-file}}"
        - - name: approval
            template: manual-approval
            when: "'{{workflow.parameters.skip-approval}}' == 'false'"
        - - name: execute-restore
            template: run-restore-script
            arguments:
              parameters:
                - name: backup-file
                  value: "{{steps.resolve-backup.outputs.parameters.backup-file}}"
                - name: target-database
                  value: "{{workflow.parameters.target-database}}"
        - - name: verify-restore
            template: verify-databases
            arguments:
              parameters:
                - name: target-database
                  value: "{{workflow.parameters.target-database}}"

    # List available backups
    - name: list-available-backups
      container:
        image: alpine:3.19
        command: ["/bin/sh", "-c"]
        args:
          - |
            echo "=== Available Backups ==="
            echo ""
            ls -lht /backup/postgres-backup-*.sql.gz 2>/dev/null | head -20 || echo "No backups found"
            echo ""
            echo "Total backups: $(ls /backup/postgres-backup-*.sql.gz 2>/dev/null | wc -l)"
        volumeMounts:
          - name: backup
            mountPath: /backup

    # Resolve 'latest' to actual filename
    - name: resolve-backup-file
      inputs:
        parameters:
          - name: requested-file
      outputs:
        parameters:
          - name: backup-file
            valueFrom:
              path: /tmp/backup-file.txt
      container:
        image: alpine:3.19
        command: ["/bin/sh", "-c"]
        args:
          - |
            set -e
            REQUESTED="{{inputs.parameters.requested-file}}"

            if [ "$REQUESTED" = "latest" ]; then
              BACKUP_FILE=$(ls -t /backup/postgres-backup-*.sql.gz 2>/dev/null | head -1 | xargs basename)
              if [ -z "$BACKUP_FILE" ]; then
                echo "ERROR: No backups found on NFS"
                exit 1
              fi
              echo "Resolved 'latest' to: $BACKUP_FILE"
            else
              BACKUP_FILE="$REQUESTED"
              if [ ! -f "/backup/$BACKUP_FILE" ]; then
                echo "ERROR: Backup file not found: $BACKUP_FILE"
                echo "Available backups:"
                ls /backup/postgres-backup-*.sql.gz 2>/dev/null || echo "None"
                exit 1
              fi
            fi

            echo "$BACKUP_FILE" > /tmp/backup-file.txt
            echo "Using backup file: $BACKUP_FILE"
        volumeMounts:
          - name: backup
            mountPath: /backup

    # Verify backup contents
    - name: verify-backup-contents
      inputs:
        parameters:
          - name: backup-file
      container:
        image: alpine:3.19
        command: ["/bin/sh", "-c"]
        args:
          - |
            set -e
            BACKUP_FILE="{{inputs.parameters.backup-file}}"

            echo "=== Verifying Backup: $BACKUP_FILE ==="
            echo ""

            # File info
            echo "File details:"
            ls -lh "/backup/$BACKUP_FILE"
            echo ""

            # Check it's valid gzip
            echo "Validating gzip integrity..."
            gunzip -t "/backup/$BACKUP_FILE" && echo "✓ Gzip file is valid"
            echo ""

            # Show databases in backup
            echo "Databases in backup:"
            gunzip -c "/backup/$BACKUP_FILE" | grep -E '^\\connect ' | grep -v 'template0\|template1\|postgres' | sort -u || echo "None found"
            echo ""

            # Show backup header
            echo "Backup header (first 20 lines):"
            gunzip -c "/backup/$BACKUP_FILE" | head -20
        volumeMounts:
          - name: backup
            mountPath: /backup
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 256Mi

    # Manual approval gate
    - name: manual-approval
      suspend: {}

    # Execute the restore using the ConfigMap script
    - name: run-restore-script
      inputs:
        parameters:
          - name: backup-file
          - name: target-database
      container:
        image: bitnami/kubectl:latest
        command: ["/scripts/postgres-restore.sh"]
        env:
          - name: BACKUP_FILE
            value: "{{inputs.parameters.backup-file}}"
          - name: TARGET_DATABASE
            value: "{{inputs.parameters.target-database}}"
        volumeMounts:
          - name: backup
            mountPath: /backup
          - name: scripts
            mountPath: /scripts
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 512Mi

    # Verify databases after restore
    - name: verify-databases
      inputs:
        parameters:
          - name: target-database
      container:
        image: bitnami/kubectl:latest
        command:
          - /bin/bash
          - -c
          - |
            set -e
            TARGET_DB="{{inputs.parameters.target-database}}"

            PRIMARY_POD=$(kubectl get pods -n postgres -l cnpg.io/cluster=postgres-cluster,cnpg.io/instanceRole=primary -o jsonpath='{.items[0].metadata.name}')

            echo "=== Post-Restore Verification ==="
            echo ""

            if [ -n "$TARGET_DB" ]; then
              echo "Verifying database: $TARGET_DB"
              kubectl exec -n postgres "$PRIMARY_POD" -- psql -U postgres -d "$TARGET_DB" -c "\dt" || echo "No tables found"
              echo ""
              kubectl exec -n postgres "$PRIMARY_POD" -- psql -U postgres -d "$TARGET_DB" -c "SELECT count(*) as table_count FROM information_schema.tables WHERE table_schema = 'public';"
            else
              echo "All databases:"
              kubectl exec -n postgres "$PRIMARY_POD" -- psql -U postgres -d postgres -c "\l"
              echo ""
              echo "Database sizes:"
              kubectl exec -n postgres "$PRIMARY_POD" -- psql -U postgres -d postgres -c "SELECT datname, pg_size_pretty(pg_database_size(datname)) as size FROM pg_database WHERE datname NOT IN ('template0', 'template1') ORDER BY pg_database_size(datname) DESC;"
            fi

            echo ""
            echo "✓ Verification complete"
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 256Mi
